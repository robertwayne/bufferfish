{
  "version": 3,
  "sources": ["../src/bufferfish.ts"],
  "sourcesContent": [
    "export class Bufferfish {\n    private inner: Uint8Array\n    private pos: number\n    private reading: boolean\n    private capacity: number\n\n    constructor(buf: ArrayBuffer = new ArrayBuffer(0)) {\n        this.inner = new Uint8Array(buf)\n        this.pos = 0\n        this.reading = false\n        this.capacity = 1024\n    }\n\n    /**\n     * Writes a byte array to the internal buffer. Returns the numbers of bytes\n     * written to the buffer.\n     *\n     * This should only be called by the library.\n     */\n    private write(buf: Uint8Array): number {\n        if (\n            this.capacity > 0 &&\n            (buf.length > this.capacity ||\n                this.inner.length + buf.length > this.capacity)\n        ) {\n            throw new Error(\"Bufferfish is full\")\n        }\n\n        this.reading = false\n\n        const tmp = new Uint8Array(this.inner.length + buf.length)\n        tmp.set(this.inner, 0)\n        tmp.set(buf, this.inner.length)\n        this.inner = tmp\n\n        const bytesWritten = buf.length\n        this.pos += bytesWritten\n\n        return bytesWritten\n    }\n\n    /**\n     * Returns the (immutable) internal Uint8Array.\n     */\n    public view = (): Uint8Array => {\n        return this.inner.slice()\n    }\n\n    /**\n     * Resets the buffer cursor to the start postion when reading after a write.\n     *\n     * This should only be called by the library.\n     */\n    private startReading(): void {\n        if (this.reading) {\n            return\n        }\n\n        this.pos = 0\n        this.reading = true\n    }\n\n    /**\n     * Sets the max capacity (in bytes) for the internal buffer.\n     * A value of 0 will allow the buffer to grow indefinitely.\n     */\n    public setMaxCapacity(capacity: number): void {\n        this.capacity = capacity\n    }\n\n    /**\n     * Returns the next byte in the buffer without advancing the cursor. Returns\n     * undefined if the cursor is at the end of the buffer.\n     */\n    public peek = (): number | null => {\n        this.startReading()\n\n        if (this.pos >= this.inner.length) {\n            return null\n        }\n\n        return this.inner.slice(this.pos, this.pos + 1)[0] ?? null\n    }\n\n    /**\n     * Returns the next n bytes in the buffer without advancing the cursor.\n     * Returns undefined if the cursor is at the end of the buffer.\n     */\n    public peekN = (n: number): Uint8Array | null => {\n        this.startReading()\n\n        if (this.pos + n > this.inner.length) {\n            return null\n        }\n\n        return this.inner.slice(this.pos, this.pos + n)\n    }\n\n    /**\n     * Appends another Bufferfish, Uint8Array, ArrayBuffer, or Array<number> to\n     * the buffer. This modifies the Bufferfish in-place.\n     */\n    public push = (\n        arr: Bufferfish | Uint8Array | ArrayBuffer | Array<number>,\n    ): void => {\n        if (arr instanceof Bufferfish) {\n            this.write(arr.view())\n        } else if (arr instanceof Uint8Array) {\n            this.write(arr)\n        } else if (arr instanceof ArrayBuffer) {\n            this.write(new Uint8Array(arr))\n        } else if (arr instanceof Array) {\n            this.write(new Uint8Array(arr))\n        } else {\n            throw new Error(\"Invalid type\")\n        }\n    }\n\n    /**\n     * Writes a single u8 to the buffer as one byte.\n     */\n    public writeUint8 = (value: number): void => {\n        if (value > 255 || value < 0) {\n            throw new Error(\"Value is out of range\")\n        }\n\n        const slice: Uint8Array = new Uint8Array(1)\n        const view = new DataView(slice.buffer)\n        view.setUint8(0, value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes a u16 to the buffer as two bytes.\n     */\n    public writeUint16 = (value: number): void => {\n        if (value > 65535 || value < 0) {\n            throw new Error(\"Value is out of range\")\n        }\n\n        const slice: Uint8Array = new Uint8Array(2)\n        const view = new DataView(slice.buffer)\n        view.setUint16(0, value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes a u32 to the buffer as four bytes.\n     */\n    public writeUint32 = (value: number): void => {\n        if (value > 4294967295 || value < 0) {\n            throw new Error(\"Value is out of range\")\n        }\n\n        const slice: Uint8Array = new Uint8Array(4)\n        const view = new DataView(slice.buffer)\n        view.setUint32(0, value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes an i8 to the buffer as one byte.\n     */\n    public writeInt8 = (value: number): void => {\n        if (value > 127 || value < -128) {\n            throw new Error(\"Value is out of range\")\n        }\n\n        const slice: Uint8Array = new Uint8Array(1)\n        const view = new DataView(slice.buffer)\n        view.setInt8(0, value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes an i16 to the buffer as two bytes.\n     */\n    public writeInt16 = (value: number): void => {\n        if (value > 32767 || value < -32768) {\n            throw new Error(\"Value is out of range\")\n        }\n\n        const slice: Uint8Array = new Uint8Array(2)\n        const view = new DataView(slice.buffer)\n        view.setInt16(0, value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes an i32 to the buffer as four bytes.\n     */\n    public writeInt32 = (value: number): void => {\n        if (value > 2147483647 || value < -2147483648) {\n            throw new Error(\"Value is out of range\")\n        }\n\n        const slice: Uint8Array = new Uint8Array(4)\n        const view = new DataView(slice.buffer)\n        view.setInt32(0, value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes a bool to the buffer as a single byte.\n     */\n    public writeBool = (value: boolean): void => {\n        this.writeUint8(value ? 1 : 0)\n    }\n\n    /**\n     * Writes a series of bools to the buffer as a single byte. This allows up\n     * to 4 bools to be represented as a single byte. The first 4 bits are used\n     * as a mask to determine which of the last 4 bits are set.\n     */\n    public writePackedBools = (values: Array<boolean>): void => {\n        if (values.length > 4) {\n            throw new Error(\n                \"Each packed bool can only represent 4 or fewer values\",\n            )\n        }\n\n        let packed_value = 0x00\n        for (const value of values) {\n            packed_value <<= 1\n            if (value) {\n                packed_value |= 1\n            }\n        }\n\n        this.writeUint8(packed_value)\n    }\n\n    /**\n     * Writes a unicode string literal to the buffer. It will be prefixed with\n     * its length in bytes as a u16 (two bytes), and each character will be 1 to\n     * 4-bytes, whichever is the smallest it can fit into.\n     */\n    public writeString = (value: string): void => {\n        const slice: Uint8Array = new TextEncoder().encode(value)\n\n        this.writeUint16(slice.length)\n        this.write(slice)\n    }\n\n    /**\n     * Writes a unicode string literal to the buffer without a length prefix.\n     * Each character will be 1 to 4-bytes, whichever is the smallest it can fit\n     * into.\n     */\n    public writeSizedString = (value: string): void => {\n        const slice: Uint8Array = new TextEncoder().encode(value)\n\n        this.write(slice)\n    }\n\n    /**\n     * Writes an array of raw bytes to the buffer. Useful for serializing ///\n       distinct structs into byte arrays and appending them to a buffer later.\n     */\n    public writeRawBytes = (value: Uint8Array): void => {\n        this.write(value)\n    }\n\n    /**\n     * Reads a u8 from the buffer.\n     */\n    public readUint8 = (): number => {\n        this.startReading()\n\n        const buf = new Uint8Array(1)\n        buf.set(this.inner.subarray(this.pos, this.pos + 1))\n        this.pos += 1\n\n        return new DataView(buf.buffer).getUint8(0)\n    }\n\n    /**\n     * Reads a u16 from the buffer.\n     */\n    public readUint16 = (): number => {\n        this.startReading()\n\n        const buf = new Uint8Array(2)\n        buf.set(this.inner.subarray(this.pos, this.pos + 2))\n        this.pos += 2\n\n        return new DataView(buf.buffer).getUint16(0)\n    }\n\n    /**\n     * Reads a u32 from the buffer.\n     */\n    public readUint32 = (): number => {\n        this.startReading()\n\n        const buf = new Uint8Array(4)\n        buf.set(this.inner.subarray(this.pos, this.pos + 4))\n        this.pos += 4\n\n        return new DataView(buf.buffer).getUint32(0)\n    }\n\n    /**\n     * Reads an i8 from the buffer.\n     */\n    public readInt8 = (): number => {\n        this.startReading()\n\n        const buf = new Uint8Array(1)\n        buf.set(this.inner.subarray(this.pos, this.pos + 1))\n        this.pos += 1\n\n        return new DataView(buf.buffer).getInt8(0)\n    }\n\n    /**\n     * Reads an i16 from the buffer.\n     */\n    public readInt16 = (): number => {\n        this.startReading()\n\n        const buf = new Uint8Array(2)\n        buf.set(this.inner.subarray(this.pos, this.pos + 2))\n        this.pos += 2\n\n        return new DataView(buf.buffer).getInt16(0)\n    }\n\n    /**\n     * Reads an i32 from the buffer.\n     */\n    public readInt32 = (): number => {\n        this.startReading()\n\n        const buf = new Uint8Array(4)\n        buf.set(this.inner.subarray(this.pos, this.pos + 4))\n        this.pos += 4\n\n        return new DataView(buf.buffer).getInt32(0)\n    }\n\n    /**\n     * Reads a bool from the buffer.\n     */\n    public readBool = (): boolean => {\n        this.startReading()\n\n        const buf = new Uint8Array(1)\n        buf.set(this.inner.subarray(this.pos, this.pos + 1))\n        this.pos += 1\n\n        return buf[0] === 1\n    }\n\n    /**\n     *\n     */\n    public readPackedBools = (): Array<boolean> => {\n        return []\n    }\n\n    /**\n     * Reads a variable length string from the buffer.\n     */\n    public readString = (): string => {\n        this.startReading()\n\n        const len = this.readUint16()\n        const slice = this.inner.subarray(this.pos, this.pos + len)\n        const str = new TextDecoder(\"utf-8\").decode(slice)\n        this.pos += len\n\n        return str\n    }\n\n    /**\n     * Reads a sized string from the buffer. You must pass the length of the\n     * string in bytes.\n     */\n    public readSizedString = (size: number): string => {\n        this.startReading()\n\n        const slice = this.inner.subarray(this.pos, this.pos + size)\n        const str = new TextDecoder(\"utf-8\").decode(slice)\n        this.pos += size\n\n        return str\n    }\n\n    /**\n     * Reads a sized string from the buffer. This will read from the buffers\n     * current position until the end of the buffer, so this function should not\n     * be used unless you know that the string is the last value in the buffer.\n     * This removes the overhead of a length prefix; it is recommended to plan\n     * your packets out such that they end with a sized string where possible.\n     */\n    public readStringRemaining = (): string => {\n        this.startReading()\n\n        const slice = this.inner.subarray(this.pos, this.inner.length)\n        const str = new TextDecoder(\"utf-8\").decode(slice)\n        this.pos = this.inner.length\n\n        return str\n    }\n\n    // public serialize = (obj: object) => {}\n\n    // public serializeNumber = (number: number) => {}\n\n    // public serializeString = (string: string) => {}\n\n    // public serializeBoolean = (bool: boolean) => {}\n}\n"
  ],
  "mappings": "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",
  "debugId": "2EE010CB4D2C009964756e2164756e21",
  "names": []
}