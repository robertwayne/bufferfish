use std::{
    fs::{File, OpenOptions},
    io::{BufRead, BufReader, Write},
};

#[cfg(feature = "derive")]
pub use bufferfish_derive::*;
pub use bufferfish_internal::*;

fn build_typescript_definitions(lines: &[String]) -> Result<String, std::io::Error> {
    let mut current_value = 0;
    let mut variant_lines = Vec::new();
    let mut inside_enum = false;

    for line in lines {
        let line = line.trim().replace(',', "").to_string();

        if line.starts_with('}') {
            break;
        }

        if line.starts_with("pub enum PacketId {") {
            inside_enum = true;
            continue;
        }

        if !inside_enum || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line.split('=').map(|s| s.trim()).collect();
        let explicit_value = parts.get(1);

        let value = match explicit_value {
            Some(value) => value.to_string(),
            None => current_value.to_string(),
        };

        variant_lines.push(format!("    {} = {}", parts[0], value));
        current_value += 1;
    }

    let lines = variant_lines.join(",\n") + ","; // Trailing comma

    let mut contents = String::new();
    contents.push_str("/* AUTOGENERATED BUFFERFISH FILE, DO NOT EDIT */\n");
    contents.push_str("/* Make sure your bundler is configured to inline TypeScript enums in order to avoid bloated codegen from the default TypeScript enum behaviour. */\n");
    contents.push_str("import { Bufferfish } from 'bufferfish';\n\n");
    contents.push_str("export enum PacketId {\n");
    contents.push_str(&lines);
    contents.push_str("\n}\n");

    Ok(contents)
}

fn build_typescript_deserializer(lines: &[String]) -> Result<String, std::io::Error> {
    let mut fn_lines = Vec::new();
    let mut interfaces = Vec::new();
    let mut inside_struct = false;
    let mut fields: Vec<(String, String)> = Vec::new();
    let mut struct_name = String::new();

    for line in lines {
        let line = line.trim().replace(',', "").to_string();

        if line.starts_with('}') {
            if inside_struct {
                if !fields.is_empty() {
                    fn_lines.push("\n    return {\n".to_string());
                    for field in &fields {
                        fn_lines.push(format!("        {},\n", field.0));
                    }
                    fn_lines.push("    };\n".to_string());
                } else {
                    fn_lines.push("    return {};\n".to_string());
                }
                fn_lines.push("};\n".to_string());

                // Add the interface definition
                let mut interface_lines = Vec::new();
                interface_lines.push(format!("export interface {} {{", struct_name));
                for (field, ts_type) in &fields {
                    interface_lines.push(format!("    {}: {};", field, ts_type));
                }
                interface_lines.push("}\n".to_string());
                interfaces.push(interface_lines.join("\n"));

                inside_struct = false;
                fields.clear();
            }
            continue;
        }

        if line.starts_with("#[bufferfish") {
            inside_struct = true;
            continue;
        }

        if !inside_struct || line.starts_with('#') || line.ends_with(';') {
            continue;
        }

        if line.starts_with("pub struct") {
            struct_name = line.split_whitespace().nth(2).unwrap().to_string();
            fn_lines.push(format!(
                "export const parse{} = (bf: Bufferfish): {} => {{\n",
                struct_name, struct_name
            ));
            continue;
        }

        let parts: Vec<&str> = line.split(':').map(|s| s.trim()).collect();
        if parts.len() < 2 {
            continue;
        }
        let field_name = parts[0].replace("pub", "").trim().to_string();

        match parts[1] {
            "u8" => {
                fields.push((field_name.clone(), "number".to_string()));
                fn_lines.push(format!("    const {} = bf.readUint8();\n", field_name));
            }
            "u16" => {
                fields.push((field_name.clone(), "number".to_string()));
                fn_lines.push(format!("    const {} = bf.readUint16();\n", field_name));
            }
            "u32" => {
                fields.push((field_name.clone(), "number".to_string()));
                fn_lines.push(format!("    const {} = bf.readUint32();\n", field_name));
            }
            "i8" => {
                fields.push((field_name.clone(), "number".to_string()));
                fn_lines.push(format!("    const {} = bf.readInt8();\n", field_name));
            }
            "i16" => {
                fields.push((field_name.clone(), "number".to_string()));
                fn_lines.push(format!("    const {} = bf.readInt16();\n", field_name));
            }
            "i32" => {
                fields.push((field_name.clone(), "number".to_string()));
                fn_lines.push(format!("    const {} = bf.readInt32();\n", field_name));
            }
            "bool" => {
                fields.push((field_name.clone(), "boolean".to_string()));
                fn_lines.push(format!("    const {} = bf.readBool();\n", field_name));
            }
            "String" => {
                fields.push((field_name.clone(), "string".to_string()));
                fn_lines.push(format!("    const {} = bf.readString();\n", field_name));
            }
            _ => {
                eprintln!("Unsupported type: {:?}", parts[1]);
            }
        }
    }

    let mut contents = String::new();

    for interface in interfaces {
        contents.push_str(&interface);
        contents.push('\n');
    }

    for line in fn_lines {
        contents.push_str(&line);
    }

    Ok(contents)
}

fn write_typescript_file(dest: &str, contents: &str) -> Result<(), std::io::Error> {
    let mut file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(dest)?;

    file.write_all(contents.as_bytes())?;

    Ok(())
}

fn read_input_file(src: &str) -> Result<Vec<String>, std::io::Error> {
    let input_file = File::open(src).map_err(|e| {
        eprintln!("Failed to open input file: {}", e);
        e
    })?;
    let reader = BufReader::new(input_file);

    let mut contents = Vec::new();
    for line in reader.lines() {
        contents.push(line?);
    }

    Ok(contents)
}

pub fn transpile(src: &str, dest: &str) -> Result<(), std::io::Error> {
    let lines = read_input_file(src)?;
    let definitions = build_typescript_definitions(&lines)?;
    let deserializer = build_typescript_deserializer(&lines)?;

    let content = format!("{}\n{}", definitions, deserializer);

    write_typescript_file(dest, &content)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transpilation() {
        let input = r#"
            pub enum PacketId {
                Foo = 0,
                Bar,
                Baz = 255,
            }

            #[bufferfish(PacketId::Foo)]
            pub struct TestPacket {
                pub a: u8,
                pub b: String,
            }

            #[bufferfish(PacketId::Leave)]
            pub struct LeavePacket;
        "#;

        let expected_output = r#"/* AUTOGENERATED BUFFERFISH FILE, DO NOT EDIT */
/* Make sure your bundler is configured to inline TypeScript enums in order to avoid bloated codegen from the default TypeScript enum behaviour. */
import { Bufferfish } from 'bufferfish';

export enum PacketId {
    Foo = 0,
    Bar = 1,
    Baz = 255,
}

export interface TestPacket {
    a: number;
    b: string;
}

export const parseTestPacket = (bf: Bufferfish): TestPacket => {
    const a = bf.readUint8();
    const b = bf.readString();

    return {
        a,
        b,
    };
};
"#;

        let lines = input
            .lines()
            .map(|s| s.to_string())
            .collect::<Vec<String>>();

        let result = transpile_lines_to_string(&lines).unwrap();

        assert_eq!(result, expected_output);
    }

    fn transpile_lines_to_string(lines: &[String]) -> Result<String, std::io::Error> {
        let definitions = build_typescript_definitions(lines)?;
        let deserializer = build_typescript_deserializer(lines)?;
        Ok(format!("{}\n{}", definitions, deserializer))
    }
}
