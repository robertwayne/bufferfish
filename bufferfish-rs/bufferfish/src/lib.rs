use std::{
    fs::{File, OpenOptions},
    io::{BufRead, BufReader, Write},
};

#[cfg(feature = "derive")]
pub use bufferfish_derive::*;
pub use bufferfish_internal::*;

fn build_typescript_definitions(lines: &[String]) -> Result<String, std::io::Error> {
    let mut current_value = 0;
    let mut variant_lines = Vec::new();
    let mut inside_enum = false;

    for line in lines {
        let line = line.trim().replace(',', "").to_string();

        if line.starts_with('}') {
            break;
        }

        if line.starts_with("pub enum PacketId {") {
            inside_enum = true;
            continue;
        }

        if !inside_enum {
            continue;
        }

        let parts: Vec<&str> = line.split('=').map(|s| s.trim()).collect();
        let explicit_value = parts.get(1);

        let value = match explicit_value {
            Some(value) => value.to_string(),
            None => current_value.to_string(),
        };

        variant_lines.push(format!("\t{} = {}", parts[0], value));
        current_value += 1;
    }

    let mut lines = variant_lines.join(",\n");
    lines.push(','); // Trailing comma

    let mut contents = String::new();
    contents.push_str("/* AUTOGENERATED BUFFERFISH FILE, DO NOT EDIT */\n\n");
    contents.push_str("/* Make sure your bundler is configured to inline TypeScript enums in order to avoid bloated codegen from the default TypeScript enum behaviour. */\n");
    contents.push_str("export enum PacketId {\n");
    contents.push_str(&lines);
    contents.push_str("\n}\n");

    Ok(contents)
}

fn write_typescript_file(dest: &str, contents: &str) -> Result<(), std::io::Error> {
    let mut file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(dest)?;

    file.write_all(contents.as_bytes())?;

    Ok(())
}

fn read_input_file(src: &str) -> Result<Vec<String>, std::io::Error> {
    let input_file = File::open(src).map_err(|e| {
        eprintln!("Failed to open input file: {}", e);
        e
    })?;
    let reader = BufReader::new(input_file);

    let mut contents = Vec::new();
    for line in reader.lines() {
        contents.push(line?);
    }

    Ok(contents)
}

pub fn transpile(src: &str, dest: &str) -> Result<(), std::io::Error> {
    let lines = read_input_file(src)?;
    let contents = build_typescript_definitions(&lines)?;

    write_typescript_file(dest, &contents)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transpilation() {
        let input = r#"
            pub enum PacketId {
                Foo = 0,
                Bar,
                Baz = 255,
            }
        "#;

        let expected = "/* AUTOGENERATED BUFFERFISH FILE, DO NOT EDIT */\n\n/* Make sure your bundler is configured to inline TypeScript enums in order to avoid bloated codegen from the default TypeScript enum behaviour. */\nexport enum PacketId {\n\tFoo = 0,\n\tBar = 1,\n\tBaz = 255,\n}\n";

        let lines = input
            .lines()
            .map(|s| s.to_string())
            .collect::<Vec<String>>();

        let result = build_typescript_definitions(&lines).unwrap();

        assert_eq!(result, expected);
    }
}
